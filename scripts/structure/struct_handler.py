# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Loop3DModelGenDockWidget
                                 A QGIS plugin
 This plugin preprocess map layers using map2loop and use its output for 3D modelling using LoopStructural.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-12-13
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Center of Exploration Targeting, UWA
        email                : michel.nzikoumamboukou@uwa.edu.au
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.core import QgsProject, QgsVectorLayer
from PyQt5.QtWidgets import (
	QComboBox,
	QPushButton,
	QLineEdit,
	QListWidget,
	QCheckBox,
	QTableWidget,
	QTableWidgetItem,
)

# from PyQt5.QtWidgets import QTableWidget, QTableWidgetItem
import pandas as pd
import fiona  # For vector files
import rasterio  # For raster files
import os, json
from pathlib import Path

# from config.loop_config import DataProcessor


class StructLayerHandler:

	def __init__(
		self,
		struct_combobox            : QComboBox,
		struct_button              : QPushButton,
		struct_clear_button        : QPushButton,
		struct_line_edit           : QLineEdit,
		sqgis_cbox                 : QCheckBox,
		sjson_cbox                 : QCheckBox,
		struct_combo_boxes         : list,
		struct_param_boxes         : list,
		struct_tableWidget         : QTableWidget,
		struct_bedding_QLineEdit   : QLineEdit,
		struct_overturned_QLineEdit: QLineEdit,
		struct_log_listWidget      : QListWidget
	):
		"""
		Initialize the GeologyLayerHandler class.

		Parameters:
		struct_combobox  (QComboBox): Main combobox for geology layers
		struct_button  (QPushButton): Button to confirm selection
		clear_button (QPushButton): Button to clear selection
		struct_line_edit  (QLineEdit): Line edit to display selected layer path
		fqgis_cbox (QCheckBox): QGIS layers checkbox
		fjson_cbox (QCheckBox): JSON layers checkbox
		"""

		#print("Initializing GeologyLayerHandler")  # Debug print
		self.struct_combobox             = struct_combobox
		self.struct_button               = struct_button
		self.struct_clear_button         = struct_clear_button
		self.struct_line_edit            = struct_line_edit
		self.sqgis_cbox                  = sqgis_cbox
		self.sjson_cbox                  = sjson_cbox
		self.struct_combo_boxes          = struct_combo_boxes
		self.struct_param_boxes          = struct_param_boxes
		self.struct_tableWidget          = struct_tableWidget
		self.struct_bedding_QLineEdit    = struct_bedding_QLineEdit
		self.struct_overturned_QLineEdit = struct_overturned_QLineEdit
		self.struct_log_listWidget       = struct_log_listWidget
		self.struct_log_listWidget.addItem("Initializing GeologyLayerHandler") 
	

		# Initialize the combobox with available layers
		self.populate_struct_layers()

		# Connect the button click event to the clear qt features
		self.struct_clear_button.clicked.connect(self.reset_features)
		self.struct_log_listWidget.addItem(f"Button connected: {self.struct_clear_button.objectName()}")  # Clear box
		self.struct_button.clicked.connect(self.handle_struct_selection)
		self.struct_log_listWidget.addItem(f"Button connected: {self.struct_button.objectName()}")  # Debug print

	def populate_struct_layers(self):
		"""
		Read all polygon layers from QGIS and populate the combobox.
		"""
		self.struct_log_listWidget.addItem("Populating struct layers")  # Debug print
		self.struct_combobox .clear()

		layers = QgsProject.instance().mapLayers().values()
		layer_count = 0  # Debug counter

		for layer in layers:
			if isinstance(layer, QgsVectorLayer):
				if layer.geometryType() == 0:  # # 0 corresponds to Point 2 # 1 corresponds to LineString # 2 corresponds to Polygon
					self.struct_combobox.addItem(layer.name(), layer)
					layer_count += 1
					self.struct_log_listWidget.addItem(f"Added layer: {layer.name()}")  # Debug print

		self.struct_log_listWidget.addItem(f"Total polygon layers found: {layer_count}")  # Debug print

	def handle_struct_selection(self):
		"""
		Handle the geology selection button click.
		"""
		self.struct_param_values = [
			"90",
			"5",
			"5000"
		]
		#print("Button clicked!")  # Debug print
		current_index = self.struct_combobox.currentIndex()
		#print(f"Current index: {current_index}")  # Debug print

		if current_index == -1:
			self.struct_log_listWidget.addItem("No item selected")  # Debug print
			return

		selected_layer = self.struct_combobox.itemData(current_index)
		self.struct_log_listWidget.addItem(f"Selected Structure layer name: {selected_layer.name()}")  # Debug print

		self.layer_path = selected_layer.source()
		self.struct_log_listWidget.addItem(f"Selected Structure Layer path: {self.layer_path}")  # Debug print

		self.struct_line_edit.setText(self.layer_path)
		self.struct_log_listWidget.addItem("Structure Parameter Line edit updated")  # Debug print
		# Create DataObject
		struct_table = StructDataTable(table_widget=self.struct_tableWidget)

		# # Load data from file
		struct_table.load_data(str(self.layer_path))
		# Extract col data
		col_extractor = ShapefileColumnExtractor(filepath=self.layer_path)
		self.col_headers = col_extractor.get_column_headers()
		#print(f" Column data is {self.col_headers}")

		# Fill the parameters
		struct_table.fill_data_in_cbox(
			struct_combo_boxes          = self.struct_combo_boxes,
			struct_param_boxes          = self.struct_param_boxes,
			struct_bedding_QLineEdit    = self.struct_bedding_QLineEdit,
			struct_overturned_QLineEdit = self.struct_overturned_QLineEdit,
			headers=self.col_headers,
		)
		# setEnable False to qt feature
		self.struct_button.setEnabled(False)



	def refresh_layers(self):
		"""
		Refresh the list of geology layers in the combobox.
		"""
		self.populate_struct_layers()

	def reset_features(self):
		"""
		Refresh the list of geology layers in the combobox.
		"""
		cbox_list = [self.sqgis_cbox, self.sjson_cbox]
		#self.SaveStruct_pushButton.setEnabled(True)
		for cbox in cbox_list:
			cbox.setEnabled(True)
			if cbox.isChecked():
				cbox.setChecked(False)
				cbox.setEnabled(True)
			else:
				pass
		for struct_cbbox in self.struct_combo_boxes:
			struct_cbbox.clear()
		for param_features in self.struct_param_boxes:
			param_features.clear()
		self.struct_button .setEnabled(True)
		self.struct_combobox .clear()
		self.struct_line_edit .clear()
		self.struct_bedding_QLineEdit.clear()
		self.struct_overturned_QLineEdit.clear()
		# Clear data table
		self.clear_table(self.struct_tableWidget)

	def clear_table(self, table):
		"""Clear all contents from the table."""
		table.clear()
		table.setRowCount(0)
		table.setColumnCount(0)


class StructDataTable:
	def __init__(self, table_widget: QTableWidget):
		"""
		Initialize the structDataTable class.

		Args:
			table_widget (QTableWidget): The QTableWidget instance to populate
		"""
		self.table          = table_widget

	def load_data(self, filepath: str) -> bool:
		"""
		Load geological data from a file and populate the table.

		Args:
			filepath (str): Path to the geological data file

		Returns:
			bool: True if data was loaded successfully, False otherwise
		"""
		if not os.path.exists(filepath):
			self.struct_log_listWidget.addItem(f"Error: File {filepath} does not exist")
			return False

		# Load the layer from the file path
		layer = QgsVectorLayer(filepath, "Layer", "ogr")

		if not layer.isValid():
			self.struct_log_listWidget.addItem(f"Failed to load the layer from: {filepath}")
			return

		# Get column names (headers)
		cols_header = [field.name() for field in layer.fields()]

		# Get the layer data (attributes)
		data = [feature.attributes() for feature in layer.getFeatures()]

		self.table.setColumnCount(len(cols_header))
		self.table.setHorizontalHeaderLabels(cols_header)

		# Set table rows count based on the data
		self.table.setRowCount(len(data))

		# Append data to the table
		for row_index, row_data in enumerate(data):
			for col_index, value in enumerate(row_data):
				self.table.setItem(row_index, col_index, QTableWidgetItem(str(value)))

	def fill_data_in_cbox(
		self,
		struct_combo_boxes         : list,
		struct_param_boxes         : list,
		headers                    : list,
		struct_bedding_QLineEdit   : QLineEdit,
		struct_overturned_QLineEdit: QLineEdit,
	):
		self.struct_combo_boxes          = struct_combo_boxes
		self.struct_param_boxes          = struct_param_boxes
		self.struct_bedding_QLineEdit    = struct_bedding_QLineEdit
		self.struct_overturned_QLineEdit = struct_overturned_QLineEdit
		self.col_headers                 = headers

		self.struct_param_values = ["30","5"]
		
		# Create sorted column data dictionary
		sorter = StratigraphySorter()
		self.sorted_data = sorter.sort_headers(headers=self.col_headers)

	   
		for index, cbox_obj in enumerate(self.struct_combo_boxes):
			if cbox_obj.objectName()=='struct_field_comboBox_4':
				dip_dir_flag= ["Dip Direction", "Strike"]
				cbox_obj.addItems(dip_dir_flag)
			else:
				cbox_obj.addItems(self.sorted_data[index])

		self.struct_user_field ={}
		# = ["num", "alpha"]
		for idx, param_obj in enumerate(self.struct_param_boxes):
			if isinstance(param_obj, QLineEdit):
				param_obj.setText(self.struct_param_values[idx])
			   
			else:
				self.struct_log_listWidget.addItem(f"Widget {i + 1} is of unknown type.")

		self.struct_bedding_QLineEdit.setText("Bedding")
		self.struct_overturned_QLineEdit.setText("Overturned")

		return 


class StratigraphySorter:
	def __init__(self):
		#

		self.geology_file_dir = Path(os.path.abspath(__file__))

		# second parent directory
		second_parent_dir = self.geology_file_dir.parents[1]
		self.config_data_path = os.path.join(
			second_parent_dir, "config", "config_parameters.json"
		)
		# Load data from JSON file
		with open(self.config_data_path, "r") as file:
			self.data = json.load(file)
		# Extract parameters from the JSON structure
		self.formation_column_to_search = self.data["Orientations_dictionary"][
			"d_params"
		]
		self.group_column_to_search = self.data["Orientations_dictionary"]["dd_params"]
		self.supergroup_column_to_search = self.data["Orientations_dictionary"][
			"sf_params"
		]
		self.description_column_to_search = self.data["Orientations_dictionary"][
			"otype_params"
		]
		self.fmcode_column_to_search = self.data["Orientations_dictionary"]["bo_params"]

		self.polygonID_column_to_search = self.data["ids_dictionary"]["o_params"]


		self.list_of_search = [
			self.formation_column_to_search,
			self.group_column_to_search,
			self.supergroup_column_to_search,
			self.description_column_to_search,
			self.fmcode_column_to_search,
			self.polygonID_column_to_search,
		]
		#print("End of stratigraphic Order")

	def sort_headers(self, headers: list):
		"""Sort headers based on matching elements in the list of search parameters."""
		self.headers = headers

		sorted_dict = {}
		for idx, search_list in enumerate(self.list_of_search):
			# Resort headers with matches from search_list first
			resorted_list = sorted(
				self.headers,
				key=lambda x: (
					x not in search_list,
					search_list.index(x) if x in search_list else float("inf"),
				),
			)
			# print(f"Match and sorted list: {resorted_list}")
			sorted_dict[idx] = resorted_list
			#print(f"I am here now: ")
		return sorted_dict


class ShapefileColumnExtractor:
	"""
	A class to extract the column headers of a shapefile's attribute table.

	Attributes:
		filepath (str): The file path to the shapefile.
	"""

	def __init__(self, filepath: str):
		"""
		Initializes the ShapefileColumnExtractor with the shapefile path.

		Args:
			filepath (str): Path to the shapefile.
		"""
		self.filepath = filepath

	def get_column_headers(self):
		"""
		Extracts and returns the column headers of the shapefile.

		Returns:
			list: A list of column names (attribute table headers).
		"""
		try:
			with fiona.open(self.filepath, "r") as shapefile:
				headers = shapefile.schema["properties"].keys()
				return list(headers)
		except Exception as e:
			self.struct_log_listWidget.addItem(f"Error reading shapefile: {e}")
			return []
