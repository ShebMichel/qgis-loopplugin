# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Loop3DModelGenDockWidget
								 A QGIS plugin
 This plugin preprocess map layers using map2loop and use its output for 3D modelling using LoopStructural.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
							 -------------------
		begin                : 2024-12-13
		git sha              : $Format:%H$
		copyright            : (C) 2024 by Center of Exploration Targeting, UWA
		email                : michel.nzikoumamboukou@uwa.edu.au
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os,json
import qgis.core
from PyQt5.QtWidgets import QFileDialog
from pathlib import Path
from PyQt5.QtCore import QVariant
from qgis.core import (
	QgsVectorLayer,
	QgsFeature,
	QgsField,
	QgsVectorFileWriter,
	QgsPointXY,
	QgsGeometry,
	QgsWkbTypes,
	QgsProject
)
import shutil
from .transform_data import transform_json
from pathlib import Path

class ShapefileExtractorFromJSON:
	# Constructor to initialize the ShapefileExtractorFromJSON object
	def __init__(self,run_log_listWidget,map2loop_button,output_folder_dict,json_path,dtm_toggle):
		# Assigning the provided arguments to the instance variables
		self.run_log_listWidget = run_log_listWidget  # Widget to display the run log
		self.map2loop_button    = map2loop_button     # Button that triggers the loop/map process
		self.output_folder_dict = output_folder_dict  # Dictionary that holds output folder paths
		self.json_path          = json_path           # Path to the JSON file to be processed
		self.dtm_toggle         = dtm_toggle          # flag to set for dtm
		
	def select_json_file(self):
		"""
		Selects the JSON file from a predefined directory.

		This function checks if the specified directory (self.json_path) exists.
		If valid, it constructs the expected JSON file path within the "process_data" 
		subdirectory and verifies its existence. If the file exists, it loads the JSON 
		configuration data.

		Logs all relevant messages in the `run_log_listWidget`.

		Returns:
			dict or None: The loaded JSON data if successful, otherwise None.
		"""
		# Check if the directory exists

		if self.json_path.exists():
			self.run_log_listWidget.addItem(f"A valid directory: {self.json_path.absolutePath()}")
		else:
			self.run_log_listWidget.addItem(f"OOPS {self.json_path} IS NOT a valid directory")
		#self.json_file_path  = self.json_path / "process_data" / "data.json"
		self.json_file_path  = Path(self.json_path.absolutePath()) / "process_data" / "data.json"
		
		try:
			# Verify the path exists
			if not self.json_file_path.exists():
				self.run_log_listWidget.addItem(f"Warning: File does not exist at {self.json_file_path}")
				
			self.run_log_listWidget.addItem(f"Selected JSON file: {self.json_file_path}")
			self.proj_config_data = self.load_json()
			return self.proj_config_data
		except Exception as e:
			self.run_log_listWidget.addItem(f"Error accessing JSON file: {e}")
			return None


	def find_json_files(self,directory):
		"""
		Searches for all files named 'data.json' within the given directory 
		and its subdirectories.

		Args:
			directory (str): The root directory to search in.

		Returns:
			list: A list of file paths matching 'data.json'.
		"""
		json_files = []
		for root, _, files in os.walk(directory):
			for file in files:
				if file.endswith("data.json"):
					json_files.append(os.path.join(root, file))
		return json_files
	

	def extract_values_excluding(self,params_dict, exclude_keys):
		"""
		Extract values from the dictionary associated with each file path, 
		excluding the specified keys.
		
		:param params_dict: The dictionary with file paths as keys and their associated values as dictionaries
		:param exclude_keys: A list of keys to exclude from the values
		
		:return: A new dictionary with file paths as keys and lists of values excluding the specified keys
		"""
		result = {}
		
		for path, param_dict in params_dict.items():
			# Create a list of values, excluding the ones in exclude_keys
			filtered_values = [value for key, value in param_dict.items() if key not in exclude_keys]
			
			# Store the result in the dictionary
			result[path] = filtered_values
		
		return result


	def load_json(self):

		"""
		Loads and parses a JSON configuration file, extracting relevant data for processing.

		This function reads a JSON file located at `self.json_file_path`, extracts
		paths and parameter dictionaries, processes specific values, and creates 
		necessary output files. Additionally, it handles copying CSV and DTM files 
		if they exist.

		The extracted data includes:
		- Geological, fault, and structural layer paths.
		- Parameter dictionaries for each layer.
		- Processed data excluding specific keys.
		- Paths for project-related outputs (DTM, metadata, etc.).
		- Copies CSV and DTM files if available.

		Logs messages for missing files and directories.

		Returns:
			dict: A dictionary containing paths and processed data for the project.
		"""

		"""Load JSON file and parse it"""
		with open(str(self.json_file_path), 'r', encoding='utf-8') as f:
			data = json.load(f)
			# Assuming the structure of the JSON file contains layer path and the dictionaries
			self.layer_path = [data["geo_path"],data["fault_path"],data["struct_path"]]
			self.param_dict = [data["geology_head"],data["fault_head"],data["struct_head"]]
			self.data_to_project = {'geology_filename':data["geo_path"],'fault_filename':data["fault_path"],"structure_filename":data["struct_path"] }
			data_to_process = dict(zip(self.layer_path,self.param_dict))
			exclude_keys = ['Sill Text', 'Intrusion Text','Fault Text', 'fdipest Text','Bedding Text', 'Overturned Text']
			self.processed_dict=self.extract_values_excluding(data_to_process, exclude_keys)
			output_directory =Path(self.json_file_path).parent
			self.create_shapefiles_with_attributes(self.processed_dict, output_directory)
			# create dictionaries/configuration files
			transform_json(self,json_path=self.json_file_path)

			try:
				self.raw_data_path = Path(data["geo_path"]).parent
				self.copy_csv_if_exists(self.raw_data_path,output_directory)
			except:
				self.run_log_listWidget.addItem(f"No colours CSV availaible, use Raw Layer Style")

			if self.dtm_toggle == "AUS":
				self.dtm_path =data["DTM path"]
				self.copy_dtm_if_exists(self.dtm_path, output_directory)
				self.run_log_listWidget.addItem(f"DTM file extracted from GA server")
				self.run_log_listWidget.addItem(f"---------DATA PREPROCESS COMPLETED-------------")
				self.run_log_listWidget.addItem(f" ********* NOW RUN MAP2LOOP ********** ")

			else:
				self.run_log_listWidget.addItem(f"DTM file extracted from GA server")
				self.run_log_listWidget.addItem(f"---------DATA PREPROCESS COMPLETED-------------")
				self.run_log_listWidget.addItem(f" ********* NOW RUN MAP2LOOP ********** ")

			# add dtm path for project
			self.data_to_project["dtm_filename"]       = data["DTM path"]
			self.data_to_project["metadata_filename"]  = os.path.join(Path(self.json_file_path).parent,'output.hjson')
			self.data_to_project["working_projection"] = data["CRS Output"]
			self.data_to_project["M2L Output"]         = self.output_folder_dict["M2L Output"] 
			self.data_to_project["L2S Output"]         = self.output_folder_dict["L2S Output"]
			# return csv path if it exist and assign it to clut_filename
			csv_path =next((f for f in os.listdir(output_directory) if f.endswith(".csv")), None)
			self.data_to_project["clut_filename"]      = os.path.join(Path(self.json_file_path).parent,str(csv_path))
			return self.data_to_project

	def create_shapefiles_with_attributes(self,params_dict, output_directory):
		"""
		Create new shapefiles using the filenames from paths, copying attributes from the original file.

		:param params_dict: Dictionary with file paths as keys and lists of columns as values
		:param output_directory: Directory where new shapefiles will be saved
		"""
		# Ensure the output directory exists
		os.makedirs(output_directory, exist_ok=True)

		for path, columns in params_dict.items():
			# Extract the filename from the path
			filename = os.path.basename(path)
			filename_strip = os.path.splitext(filename)[0] # Remove the file extension
			filename_strip =f"{filename_strip}_proc"  # Add '_proc' to the filename

			# Normalize output path
			output_path = os.path.normpath(os.path.join(output_directory, f"{filename_strip}.shp"))

			# Remove existing file if it exists
			if os.path.exists(output_path):
				os.remove(output_path)

			# Load the input layer
			input_layer = QgsVectorLayer(path, "input_layer", "ogr")
			if not input_layer.isValid():
				#print(f"Error loading layer: {path}")
				self.run_log_listWidget.addItem(f"Error loading layer: {path}")
				continue

			# Detect geometry type
			geometry_type = input_layer.geometryType()
			if geometry_type == QgsWkbTypes.PointGeometry:
				geometry_string = "Point"
			elif geometry_type == QgsWkbTypes.LineGeometry:
				geometry_string = "LineString"
			elif geometry_type == QgsWkbTypes.PolygonGeometry:
				geometry_string = "Polygon"
			else:
				#print(f"Unsupported geometry type for {path}")
				self.run_log_listWidget.addItem(f"Unsupported geometry type for {path}")
				continue

			# Create an output layer with the same CRS and geometry type
			crs = input_layer.crs().authid()
			output_layer = QgsVectorLayer(f"{geometry_string}?crs={crs}", filename_strip, "memory")
			output_provider = output_layer.dataProvider()

			# Add fields (columns) to the new shapefile
			input_fields = input_layer.fields()
			for field in input_fields:
				if field.name() in columns:
					output_provider.addAttributes([QgsField(field.name(), field.type())])
			output_layer.updateFields()

			# Copy features from the input layer
			for input_feature in input_layer.getFeatures():
				output_feature = QgsFeature(output_layer.fields())
				output_feature.setGeometry(input_feature.geometry())
				output_feature.setAttributes([input_feature[field.name()] for field in output_layer.fields()])
				output_provider.addFeature(output_feature)

			# Save the output layer to a shapefile
			error = QgsVectorFileWriter.writeAsVectorFormat(output_layer, output_path, "UTF-8", output_layer.crs(), "ESRI Shapefile")
			if error[0] == QgsVectorFileWriter.NoError:
				self.run_log_listWidget.addItem(f"Shapefile created: {output_path}")
			else:
				self.run_log_listWidget.addItem(f"Error creating shapefile for {filename_strip}: Code {error[0]}, Message '{error[1]}'")


	def copy_dtm_if_exists(self,dtm_path, output_directory):
		"""
		Copies the DTM file to the output directory if it exists.

		:param dtm_path: Path to the DTM file
		:param output_directory: Directory where the DTM file should be copied
		"""
		#self.run_log_listWidget = run_log_listWidget

		if os.path.exists(dtm_path):
			# Ensure the output directory exists
			os.makedirs(output_directory, exist_ok=True)

			# Get the filename from the DTM path
			dtm_filename = os.path.basename(dtm_path)
			output_path = os.path.join(output_directory, dtm_filename)

			# Copy the file
			shutil.copy2(dtm_path, output_path)
			#print(f"DTM file copied to: {output_path}")
			self.run_log_listWidget.addItem(f"DTM file copied to: {output_path}")
			self.run_log_listWidget.addItem(f"---------DATA PREPROCESS COMPLETED-------------")
			self.add_all_layers_from_directory(output_directory)
			self.run_log_listWidget.addItem(f" ********* NOW RUN MAP2LOOP ********** ")
			self.map2loop_button.setEnabled(True)
			
		else:
			self.run_log_listWidget.addItem(f"DTM file not found: {dtm_path}")


	def copy_csv_if_exists(self,folder_path,output_directory):
		"""
		Copies the DTM file to the output directory if it exists.

		:param dtm_path: Path to the DTM file
		:param output_directory: Directory where the DTM file should be copied
		"""
		#try:
		search_string = "_colours.csv"
		# Loop through all files in the folder
		for root, dirs, files in os.walk(folder_path):
			for file in files:
				# Get the full file path
				file_path = os.path.join(root, file)
				
				# Check if the search string is in the file path
				if search_string in file_path:
					self.run_log_listWidget.addItem(f"Found '{search_string}' in the file path: {file_path}")
					csv_path =file_path
									# Copy the file
					shutil.copy(file_path, output_directory)
					self.run_log_listWidget.addItem(f"Colour CSV  file copied to: {output_directory}")
					return
				else:
					return print(f"Error")
		return

	def add_all_layers_from_directory(self,output_directory):
		"""
		Add all shapefiles from the output directory to the QGIS panel.

		:param output_directory: Path to the directory containing shapefiles.
		"""
		self.run_log_listWidget.addItem(f"Loading process layers in QGIS panel")
		# Ensure the directory exists
		if not os.path.exists(output_directory):
			self.run_log_listWidget.addItem(f"The directory {output_directory} does not exist.")
			return

		# Loop through all files in the directory
		for filename in os.listdir(output_directory):
			file_path = os.path.join(output_directory, filename)

			# Only process shapefiles (.shp)
			if filename.endswith(".shp"):
				# Create the layer
				layer = QgsVectorLayer(file_path, filename, "ogr")

				# Check if the layer is valid
				if layer.isValid():
					# Add the layer to the QGIS project
					QgsProject.instance().addMapLayer(layer)
					self.run_log_listWidget.addItem(f"Layer: {filename} added in QGIS panel ")
				else:
					self.run_log_listWidget.addItem(f"Invalid QGIS layer: {filename}")
			else:
				self.run_log_listWidget.addItem(f"Skipping non-shapefile: {filename}")


