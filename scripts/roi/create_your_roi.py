# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Loop3DModelGenDockWidget
                                 A QGIS plugin
 This plugin preprocess map layers using map2loop and use its output for 3D modelling using LoopStructural.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-12-13
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Center of Exploration Targeting, UWA
        email                : michel.nzikoumamboukou@uwa.edu.au
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""


# """
# Michel Nzikou @UWA-MinEx CRC Perth, February 15, 2023
# This python module create:
#     1- a polygon or region of interest shape file which is saved in your data directory
#     2- then new layer is created by clipping the roi into the bigger layer, with overlay=roi.
#     3- the output layer have the size of roi with data from the input layer
#     4- the output layer directory is in the same as the input layer
# """

from qgis.core import (
    QgsProject,
    QgsVectorLayer,
    QgsRasterLayer,
    QgsProcessingFeatureSourceDefinition,
    QgsProcessingException,
    QgsProcessingFeedback,
    QgsVectorFileWriter,
)
from qgis.utils import iface
from PyQt5.QtWidgets import QMessageBox
import geopandas as gpd
import os, processing


def create_scratch_layer_and_activate_clipping(self, flag):
    """
    Create a scratch layer and activate the clipping tool to create an ROI.

    Args:
        flag (int):
            - 0: Create a temporary polygon layer.
            - 1: Create a temporary point layer.

    Returns:
        QgsVectorLayer: The created scratch layer.
    """
    # Determine the layer type based on the flag
    if flag == 0:  # Polygon layer
        layer_type = "Polygon?crs=EPSG:4326"
    elif flag == 1:  # Point layer
        layer_type = "Point?crs=EPSG:4326"
    else:
        raise ValueError("Invalid flag value. Use 0 for Polygon or 1 for Point.")

    # Create a scratch layer
    new_layer = QgsVectorLayer(layer_type, "ROI_Layer", "memory")
    if not new_layer.isValid():
        raise RuntimeError("Failed to create a scratch layer.")

    # Add the layer to the QGIS project
    QgsProject.instance().addMapLayer(new_layer)

    # Activate editing mode
    new_layer.startEditing()

    # Notify the user to draw their ROI
    QMessageBox.about(
        self, "ROI Selection", "Draw your Region of Interest (ROI) on the map."
    )

    # Use the built-in QGIS "Add Feature" tool for user interaction
    # iface.actionAddFeature().trigger()
    self.Ok_ClipLayer.setEnabled(True)

    return new_layer


def save_roi_from_panel(self, input_path):
    """
    Saves the ROI layer from the QGIS Processing Panel
    """
    # Get all layers from the project
    layers = QgsProject.instance().mapLayers().values()
    self.input_path = input_path
    # Find the ROI layer
    roi_layer = None
    for layer in layers:
        if "ROI" in layer.name().upper():
            roi_layer = layer
            break

    if roi_layer is None:
        iface.messageBar().pushWarning("Warning", "No ROI layer found in the project.")
        return

    try:
        # Create a default filename
        self.default_filename = f"ROI.shp"
        filename = os.path.join(str(self.input_path), str(self.default_filename))

        if filename:
            options = QgsVectorFileWriter.SaveVectorOptions()
            options.driverName = "ESRI Shapefile"

            result = QgsVectorFileWriter.writeAsVectorFormat(
                roi_layer, filename, options=options
            )
            if result[0] == QgsVectorFileWriter.NoError:
                new_layer = QgsVectorLayer(filename, f"{self.default_filename}", "ogr")
                if new_layer.isValid():

                    try:
                        # Read the shapefile
                        gdf = gpd.read_file(filename)
                        # Check if it's empty
                        if gdf.empty:
                            iface.messageBar().pushCritical(
                                "Error",
                                f"The shapefile '{self.default_filename}' is empty, please draw the ROI layer",
                            )
                        else:
                            QgsProject.instance().addMapLayer(new_layer)
                            iface.messageBar().pushSuccess(
                                "Success", f"ROI Layer saved successfully to {filename}"
                            )
                            return filename
                    except Exception as e:
                        print(f"Error reading the shapefile: {e}")

            else:
                iface.messageBar().pushCritical(
                    "Error", f"Failed to save ROI layer: {result[1]}"
                )

    except Exception as e:
        iface.messageBar().pushCritical("Error", f"Error saving ROI layer: {str(e)}")


class DataClipper:
    def __init__(self, roi_path):
        """
        Initialize the clipper with an ROI shapefile.
        :param roi_path: Path to the Region of Interest (ROI) shapefile.
        """
        self.roi_layer = QgsVectorLayer(roi_path, "ROI", "ogr")
        if not self.roi_layer.isValid():
            raise Exception("Invalid ROI layer. Check the path.")

    def clip_vector_layer(self, input_path, output_path):
        """
        Clip a vector layer using the ROI.
        :param input_path: Path to the input vector layer.
        :param output_path: Path to save the clipped vector layer.
        """
        vector_layer = QgsVectorLayer(input_path, "Input Vector Layer", "ogr")
        if not vector_layer.isValid():
            raise Exception("Invalid vector layer. Check the path.")

        feedback = QgsProcessingFeedback()
        try:
            params = {
                "INPUT": input_path,
                "OVERLAY": self.roi_layer,
                "OUTPUT": output_path,
            }
            # params = {
            #     "INPUT": QgsProcessingFeatureSourceDefinition(input_path, True),
            #     "OVERLAY": self.roi_layer,
            #     "OUTPUT": output_path,
            # }
            processing.run("native:clip", params, feedback=feedback)
            print(f"Clipped vector layer saved to {output_path}.")
        except QgsProcessingException as e:
            print(f"Error clipping vector layer: {e}")

    def clip_raster_layer(self, input_path, output_path):
        """
        Clip a raster layer using the ROI.
        :param input_path: Path to the input raster layer.
        :param output_path: Path to save the clipped raster layer.
        """
        raster_layer = QgsRasterLayer(input_path, "Input Raster Layer")
        if not raster_layer.isValid():
            raise Exception("Invalid raster layer. Check the path.")

        feedback = QgsProcessingFeedback()
        try:
            params = {
                "INPUT": input_path,
                "MASK": self.roi_layer,
                "SOURCE_CRS": None,
                "TARGET_CRS": None,
                "TARGET_EXTENT": None,
                "NODATA": None,
                "ALPHA_BAND": False,
                "CROP_TO_CUTLINE": False,
                "KEEP_RESOLUTION": True,
                "SET_RESOLUTION": False,
                "X_RESOLUTION": None,
                "Y_RESOLUTION": None,
                "MULTITHREADING": False,
                "OPTIONS": "",
                "DATA_TYPE": 0,
                "EXTRA": "",
                "OUTPUT": output_path,
            }
            processing.run("gdal:cliprasterbymasklayer", params, feedback=feedback)
            print(f"Clipped raster layer saved to {output_path}.")
        except QgsProcessingException as e:
            print(f"Error clipping raster layer: {e}")

    def clip_data(self, input_paths, output_paths):
        """
        Clip multiple layers of different types (polygons, points, lines, rasters).
        :param input_paths: Dictionary with keys ('filename.shp', 'filename.tif') and corresponding file paths.
        :param output_paths: Dictionary with keys ('geol,fault,structpoint, 'raster') and corresponding output file paths.
        """
        for key, value in input_paths.items():
            if ".shp" in key:

                self.clip_vector_layer(value, output_paths[str(key)])
                print(f"{key} is clipped and saved")
            else:
                self.clip_raster_layer(value, output_paths[str(key)])
                print(f"{key} is clipped and saved")
        return "Done Clipping"

    def list_and_remove_roi_layer(layer_name):
        """
        Lists all layers in the QGIS Layers panel, prints their names,
        and removes any layer named 'ROI_layer'.
        """
        # Get the current QGIS project instance
        project = QgsProject.instance()

        # Get all layers in the project
        layers = project.mapLayers().values()

        # Iterate through layers
        for layer in layers:
            print(f"Layer name: {layer.name()}")  # Print layer name
            # if layer.name() == str(layer_name):  # "ROI_layer":
            #     # Remove the layer if its name matches 'ROI_layer'
            #     project.removeMapLayer(layer)
            #     print("Layer 'ROI_layer' removed.")
        return
