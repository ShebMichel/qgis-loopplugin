# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Loop3DModelGenDockWidget
								 A QGIS plugin
 This plugin preprocess map layers using map2loop and use its output for 3D modelling using LoopStructural.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
							 -------------------
		begin                : 2024-12-13
		git sha              : $Format:%H$
		copyright            : (C) 2024 by Center of Exploration Targeting, UWA
		email                : michel.nzikoumamboukou@uwa.edu.au
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.core import QgsProject, QgsVectorLayer
from PyQt5.QtWidgets import (
	QComboBox,
	QPushButton,
	QLineEdit,
	QListWidget,
	QCheckBox,
	QTableWidget,
	QTableWidgetItem,
)

# from PyQt5.QtWidgets import QTableWidget, QTableWidgetItem
import pandas as pd
import fiona  # For vector files
import rasterio  # For raster files
import os, json
from pathlib import Path

# from config.loop_config import DataProcessor


class GeologyLayerHandler:

	def __init__(
		self,
		geology_combobox      : QComboBox,
		geology_button        : QPushButton,
		clear_button          : QPushButton,
		geology_line_edit     : QLineEdit,
		qgis_cbox             : QCheckBox,
		json_cbox             : QCheckBox,
		geology_combo_boxes   : list,
		geology_param_boxes   : list,
		geology_tableWidget   : QTableWidget,
		sill_QLineEdit        : QLineEdit,
		intrusion_QLineEdit   : QLineEdit,
		geology_log_listWidget: QListWidget,
	):
		"""
		Initialize the GeologyLayerHandler class.

		Parameters:
		geology_combobox (QComboBox): Main combobox for geology layers
		geology_button (QPushButton): Button to confirm selection
		clear_button (QPushButton): Button to clear selection
		geology_line_edit (QLineEdit): Line edit to display selected layer path
		qgis_cbox (QCheckBox): QGIS layers checkbox
		json_cbox (QCheckBox): JSON layers checkbox
		"""

		self.geology_combobox       = geology_combobox
		self.geology_button         = geology_button
		self.clear_button           = clear_button
		self.geology_line_edit      = geology_line_edit
		self.qgis_cbox              = qgis_cbox
		self.json_cbox              = json_cbox
		self.geology_combo_boxes    = geology_combo_boxes
		self.geology_param_boxes    = geology_param_boxes
		self.geology_tableWidget    = geology_tableWidget
		self.sill_QLineEdit         = sill_QLineEdit
		self.intrusion_QLineEdit    = intrusion_QLineEdit
		self.geology_log_listWidget = geology_log_listWidget
		self.geology_log_listWidget.addItem("Initializing GeologyLayerHandler") 
	
		# Initialize the combobox with available layers
		self.populate_geology_layers()

		# Connect the button click event to the clear qt features
		self.clear_button.clicked.connect(self.reset_features)
		self.geology_log_listWidget.addItem(f"Button connected: {self.clear_button.objectName()}")
		#print(f"Button connected: {self.clear_button.objectName()}")  # Clear box
		self.geology_button.clicked.connect(self.handle_geology_selection)
		self.geology_log_listWidget.addItem(f"Button connected: {self.geology_button.objectName()}")
		#print(f"Button connected: {self.geology_button.objectName()}")  # Debug print

	def populate_geology_layers(self):
		"""
		Read all polygon layers from QGIS and populate the combobox.
		"""
		self.geology_log_listWidget.addItem("Populating geology layers")  # Debug print
		self.geology_combobox.clear()

		layers = QgsProject.instance().mapLayers().values()
		
		layer_count = 0  # Debug counter

		for layer in layers:
			if isinstance(layer, QgsVectorLayer):
				
				if layer.geometryType() == 2:  # 2 represents polygon geometry
					self.geology_combobox.addItem(layer.name(), layer)
					self.geology_log_listWidget.addItem(f"Added Geology layer in combobox: {layer.name()}")
					layer_count += 1
					 

		self.geology_log_listWidget.addItem(f"Total polygon layers found: {layer_count}")  # Debug print
				

	def handle_geology_selection(self):
		"""
		Handle the geology selection button click.
		"""
		self.geology_param_values = [
			"45",
			["domes", "saucers", "pendant"],
			["0", "1"],
			"10000",
			"5000",
			"5",
			"-999",
			"5",
			"30",
		]
		#print("Button clicked!")  # Debug print
		current_index = self.geology_combobox.currentIndex()
		#print(f"Current index: {current_index}")  # Debug print

		if current_index == -1:
			self.geology_log_listWidget.addItem("No item selected")  # Debug print
			return

		selected_layer = self.geology_combobox.itemData(current_index)
		self.geology_log_listWidget.addItem(f"Selected Geology layer name: {selected_layer.name()}")  # Debug print

		self.layer_path = selected_layer.source()
		self.geology_log_listWidget.addItem(f"Selected Geology Layer path: {self.layer_path}")  # Debug print

		self.geology_line_edit.setText(self.layer_path)
		self.geology_log_listWidget.addItem("Geology Parameter line edit updated")  # Debug print
		# Create DataObject
		geo_table = GeologicalDataTable(table_widget=self.geology_tableWidget)

		# # Load data from file
		geo_table.load_data(str(self.layer_path))
		# Extract col data
		col_extractor = ShapefileColumnExtractor(filepath=self.layer_path)
		self.col_headers = col_extractor.get_column_headers()
		#print(f" Column data is {self.col_headers}")

		# Fill the parameters
		geo_table.fill_data_in_cbox(
			geology_combo_boxes=self.geology_combo_boxes,
			geology_param_boxes=self.geology_param_boxes,
			sill_QLineEdit=self.sill_QLineEdit,
			intrusion_QLineEdit=self.intrusion_QLineEdit,
			headers=self.col_headers,
		)
		# setEnable False to qt feature
		self.geology_button.setEnabled(False)



	def refresh_layers(self):
		"""
		Refresh the list of geology layers in the combobox.
		"""
		self.populate_geology_layers()

	def reset_features(self):
		"""
		Refresh the list of geology layers in the combobox.
		"""
		cbox_list = [self.qgis_cbox, self.json_cbox]
		#self.SaveGeology_pushButton.setEnabled(True)
		for cbox in cbox_list:
			cbox.setEnabled(True)
			if cbox.isChecked():
				cbox.setChecked(False)
				cbox.setEnabled(True)
			else:
				pass
		for geology_cbbox in self.geology_combo_boxes:
			geology_cbbox.clear()
		for param_features in self.geology_param_boxes:
			param_features.clear()
		self.geology_button.setEnabled(True)
		self.geology_combobox.clear()
		self.geology_line_edit.clear()
		self.sill_QLineEdit.clear()
		self.intrusion_QLineEdit.clear()
		# Clear data table
		self.clear_table(self.geology_tableWidget)

	def clear_table(self, table):
		"""Clear all contents from the table."""
		table.clear()
		table.setRowCount(0)
		table.setColumnCount(0)


class GeologicalDataTable:
	def __init__(self, table_widget: QTableWidget):
		"""
		Initialize the GeologicalDataTable class.

		Args:
			table_widget (QTableWidget): The QTableWidget instance to populate
		"""
		self.table          = table_widget

	def load_data(self, filepath: str) -> bool:
		"""
		Load geological data from a file and populate the table.

		Args:
			filepath (str): Path to the geological data file

		Returns:
			bool: True if data was loaded successfully, False otherwise
		"""
		if not os.path.exists(filepath):
			self.geology_log_listWidget.addItem(f"Error: File {filepath} does not exist")
			return False

		# Load the layer from the file path
		layer = QgsVectorLayer(filepath, "Layer", "ogr")

		if not layer.isValid():
			self.geology_log_listWidget.addItem(f"Failed to load the layer from: {filepath}")
			return

		# Get column names (headers)
		cols_header = [field.name() for field in layer.fields()]

		# Get the layer data (attributes)
		data = [feature.attributes() for feature in layer.getFeatures()]

		self.table.setColumnCount(len(cols_header))
		self.table.setHorizontalHeaderLabels(cols_header)

		# Set table rows count based on the data
		self.table.setRowCount(len(data))

		# Append data to the table
		for row_index, row_data in enumerate(data):
			for col_index, value in enumerate(row_data):
				self.table.setItem(row_index, col_index, QTableWidgetItem(str(value)))

	def fill_data_in_cbox(
		self,
		geology_combo_boxes: list,
		geology_param_boxes: list,
		headers: list,
		sill_QLineEdit: QLineEdit,
		intrusion_QLineEdit: QLineEdit,
	):
		self.geology_combo_boxes = geology_combo_boxes
		self.geology_param_boxes = geology_param_boxes
		self.sill_QLineEdit = sill_QLineEdit
		self.intrusion_QLineEdit = intrusion_QLineEdit
		self.col_headers = headers

		self.geology_param_values = [
			"45",
			["domes", "saucers", "pendant"],
			["0", "1"],
			"10000",
			"5000",
			"5",
			"-999",
			"5",
			"30",
		]
		
		# Create sorted column data dictionary
		sorter = StratigraphySorter()
		self.sorted_data = sorter.sort_headers(headers=self.col_headers)

	   
		for index, cbox_obj in enumerate(self.geology_combo_boxes):
			#print(self.sorted_data[index])
			cbox_obj.addItems(self.sorted_data[index])

		self.geol_user_field ={}
		for idx, param_obj in enumerate(self.geology_param_boxes):
			if isinstance(param_obj, QComboBox):
			
				param_obj.addItems(self.geology_param_values[idx])
			elif isinstance(param_obj, QLineEdit):
				param_obj.setText(self.geology_param_values[idx])
			else:
				self.geology_log_listWidget.addItem(f"Widget {i + 1} is of unknown type.")

		self.sill_QLineEdit.setText("sill")
		self.intrusion_QLineEdit.setText("intrusive")

		return 


class StratigraphySorter:
	def __init__(self):
		#

		self.geology_file_dir = Path(os.path.abspath(__file__))

		# second parent directory
		second_parent_dir = self.geology_file_dir.parents[1]
		self.config_data_path = os.path.join(
			second_parent_dir, "config", "config_parameters.json"
		)
		# Load data from JSON file
		with open(self.config_data_path, "r") as file:
			self.data = json.load(file)
		# Extract parameters from the JSON structure
		self.formation_column_to_search = self.data["stratigraphy_dictionary"][
			"c_params"
		]
		self.group_column_to_search = self.data["stratigraphy_dictionary"]["g_params"]
		self.supergroup_column_to_search = self.data["stratigraphy_dictionary"][
			"g2_params"
		]
		self.description_column_to_search = self.data["stratigraphy_dictionary"][
			"ds_params"
		]
		self.fmcode_column_to_search = self.data["stratigraphy_dictionary"]["u_params"]
		self.rocktype1_column_to_search = self.data["stratigraphy_dictionary"][
			"r1_params"
		]
		self.rocktype2_column_to_search = self.data["stratigraphy_dictionary"][
			"r2_params"
		]
		self.polygonID_column_to_search = self.data["ids_dictionary"]["o_params"]
		self.minage_column_to_search = self.data["timing"]["min_params"]
		self.maxage_column_to_search = self.data["timing"]["max_params"]
		self.list_of_search = [
			self.formation_column_to_search,
			self.group_column_to_search,
			self.supergroup_column_to_search,
			self.description_column_to_search,
			self.fmcode_column_to_search,
			self.rocktype1_column_to_search,
			self.rocktype2_column_to_search,
			self.polygonID_column_to_search,
			self.minage_column_to_search,
			self.maxage_column_to_search,
		]
		#print("End of stratigraphic Order")

	def sort_headers(self, headers: list):
		"""Sort headers based on matching elements in the list of search parameters."""
		self.headers = headers

		sorted_dict = {}
		for idx, search_list in enumerate(self.list_of_search):
			# Resort headers with matches from search_list first
			resorted_list = sorted(
				self.headers,
				key=lambda x: (
					x not in search_list,
					search_list.index(x) if x in search_list else float("inf"),
				),
			)
			# print(f"Match and sorted list: {resorted_list}")
			sorted_dict[idx] = resorted_list
			#print(f"I am here now: ")
		return sorted_dict


class ShapefileColumnExtractor:
	"""
	A class to extract the column headers of a shapefile's attribute table.

	Attributes:
		filepath (str): The file path to the shapefile.
	"""

	def __init__(self, filepath: str):
		"""
		Initializes the ShapefileColumnExtractor with the shapefile path.

		Args:
			filepath (str): Path to the shapefile.
		"""
		self.filepath = filepath

	def get_column_headers(self):
		"""
		Extracts and returns the column headers of the shapefile.

		Returns:
			list: A list of column names (attribute table headers).
		"""
		try:
			with fiona.open(self.filepath, "r") as shapefile:
				headers = shapefile.schema["properties"].keys()
				return list(headers)
		except Exception as e:
			self.geology_log_listWidget.addItem(f"Error reading shapefile: {e}")
			return []
