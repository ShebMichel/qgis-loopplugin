# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Loop3DModelGenDockWidget
                                 A QGIS plugin
 This plugin preprocess map layers using map2loop and use its output for 3D modelling using LoopStructural.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-12-13
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Center of Exploration Targeting, UWA
        email                : michel.nzikoumamboukou@uwa.edu.au
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.core import QgsRasterLayer, QgsVectorLayer, QgsProject, QgsMapLayer, QgsWkbTypes
from qgis.PyQt.QtWidgets import QMessageBox
from typing import List, Optional, Union, Type

class SmartLayerPathSelector:
    """
    A simple class to handle layer path selection from QGIS layers panel with
    basic filtering capabilities for layer type and geometry.
    """
    def __init__(self, line_edit, layer_config: dict):
        """
        Initialize the layer path selector.
        
        Args:
            line_edit: QLineEdit widget where the layer path will be displayed
            layer_config: Dictionary containing layer configuration:
                {
                    'type': QgsRasterLayer or QgsVectorLayer,
                    'geometry_type': QgsWkbTypes.GeometryType (only for vector layers)
                }
        """
        self.line_edit = line_edit
        self.config = layer_config
        
        # Mapping for geometry type descriptions
        self.geometry_types = {
            QgsWkbTypes.PointGeometry: "Point",
            QgsWkbTypes.LineGeometry: "Line",
            QgsWkbTypes.PolygonGeometry: "Polygon"
        }

    def validate_layer(self, layer: QgsMapLayer) -> tuple[bool, str]:
        """
        Validate if a layer meets the specified requirements.
        
        Args:
            layer: QgsMapLayer to validate
            
        Returns:
            Tuple of (is_valid: bool, error_message: str)
        """
        # Check layer type
        if not isinstance(layer, self.config['type']):
            return False, f"Layer is not a {self.config['type'].__name__}"
            
        # Check geometry type only for vector layers
        if self.config['type'] == QgsVectorLayer and 'geometry_type' in self.config:
            if layer.geometryType() != self.config['geometry_type']:
                expected = self.geometry_types.get(self.config['geometry_type'], "Unknown")
                actual = self.geometry_types.get(layer.geometryType(), "Unknown")
                return False, f"Expected {expected} geometry, found {actual}"
        
        return True, ""

    def get_layer_paths(self) -> List[tuple]:
        """
        Get file paths of all valid layers in QGIS project.
        
        Returns:
            List of tuples containing (layer name, file path, validation message)
        """
        project = QgsProject.instance()
        layer_paths = []
        
        for layer in project.mapLayers().values():
            is_valid, message = self.validate_layer(layer)
            if is_valid:
                layer_paths.append((layer.name(), layer.source(), "✓ Valid"))
            else:
                layer_paths.append((layer.name(), layer.source(), f"❌ {message}"))
                
        return layer_paths

    def select_layer_path(self) -> Optional[str]:
        """
        Select a layer path from available layers with validation feedback.
        
        Returns:
            Selected layer path or None if no selection was made
        """
        layer_paths = self.get_layer_paths()
        valid_layers = [(name, path) for name, path, msg in layer_paths if msg.startswith("✓")]
        
        if not layer_paths:
            QMessageBox.warning(
                None,
                "No Layers Found",
                f"No layers found in the project. Please add appropriate layers first."
            )
            return None
            
        if not valid_layers:
            msg_box = QMessageBox()
            msg_box.setIcon(QMessageBox.Warning)
            msg_box.setWindowTitle("Invalid Layers")
            msg_box.setText("Available layers:")
            details = "\n".join(f"{name}: {msg}" for name, _, msg in layer_paths)
            msg_box.setDetailedText(details)
            msg_box.exec_()
            return None
            
        if len(valid_layers) == 1:
            return valid_layers[0][1]
            
        # Show selection dialog with validation status
        msg_box = QMessageBox()
        msg_box.setIcon(QMessageBox.Question)
        msg_box.setWindowTitle("Select Layer")
        msg_box.setText("Select a valid layer:")
        
        buttons = []
        for layer_name, path, msg in layer_paths:
            button_text = f"{layer_name} ({path}) {msg}"
            button = msg_box.addButton(button_text, QMessageBox.ActionRole)
            buttons.append(button)
            if not msg.startswith("✓"):
                button.setEnabled(False)
        
        cancel_button = msg_box.addButton("Cancel", QMessageBox.RejectRole)
        
        msg_box.exec_()
        clicked_button = msg_box.clickedButton()
        
        if clicked_button == cancel_button:
            return None
            
        selected_index = buttons.index(clicked_button)
        return layer_paths[selected_index][1]

    def update_line_edit(self) -> None:
        """
        Update the QLineEdit with the selected layer path.
        """
        selected_path = self.select_layer_path()
        if selected_path:
            self.line_edit.setText(selected_path)

# Example usage:
'''
# For a polygon vector layer
polygon_config = {
    'type': QgsVectorLayer,
    'geometry_type': QgsWkbTypes.PolygonGeometry
}
polygon_selector = SmartLayerPathSelector(self.lineEdit_polygon_path, polygon_config)

# For a line vector layer
line_config = {
    'type': QgsVectorLayer,
    'geometry_type': QgsWkbTypes.LineGeometry
}
line_selector = SmartLayerPathSelector(self.lineEdit_line_path, line_config)

# For a point vector layer
point_config = {
    'type': QgsVectorLayer,
    'geometry_type': QgsWkbTypes.PointGeometry
}
point_selector = SmartLayerPathSelector(self.lineEdit_point_path, point_config)

# For a raster layer
raster_config = {
    'type': QgsRasterLayer
}
raster_selector = SmartLayerPathSelector(self.lineEdit_raster_path, raster_config)

# Use the selectors
polygon_selector.update_line_edit()
line_selector.update_line_edit()
point_selector.update_line_edit()
raster_selector.update_line_edit()
'''
